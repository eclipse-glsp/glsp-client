/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { Container, ContainerModule, interfaces } from 'inversify';
import { MaybeArray, asArray, distinctAdd, remove } from './array-util';
import { hasFunctionProp, hasNumberProp } from './type-util';

/**
 * A wrapper interface to get access to the binding related functions
 * for an inversify container.
 */
export interface BindingContext {
    bind: interfaces.Bind;
    unbind: interfaces.Unbind;
    isBound: interfaces.IsBound;
    rebind: interfaces.Rebind;
}

/**
 * Initializes a container with the given {@link ContainerConfiguration}. The container configuration
 * consists of the set of {@link ContainerModule}s that should be loaded in the container.
 * In addition, for more fine-grained control {@link ModuleConfiguration}s can be passed as part fo the container configuration
 * Module loading is distinct,this means each module will only get loaded once even if it is configured multiple times.
  @param containerConfigurations
 *          Custom modules to be loaded in addition to the default modules and/or default modules that should be excluded.
  @returns The initialized container.
 */
export function initializeContainer(container: Container, ...containerConfigurations: ContainerConfiguration): Container {
    const modules = resolveContainerConfiguration(...containerConfigurations);
    container.load(...modules);
    return container;
}

/**
 *  Processes the given container configurations and returns the corresponding set of {@link ContainerModule}s.
 * @param containerConfigurations The container configurations to resolves
 * @returns an Array of resolved container modules
 */
export function resolveContainerConfiguration(...containerConfigurations: ContainerConfiguration): ContainerModule[] {
    const modules: ContainerModule[] = [];
    containerConfigurations.forEach(config => {
        if (isContainerModule(config)) {
            distinctAdd(modules, config);
        } else {
            if (config.remove) {
                remove(modules, ...asArray(config.remove));
            }
            if (config.add) {
                distinctAdd(modules, ...asArray(config.add));
            }
        }
    });
    return modules;
}
/**
 * The container modules might originate form different inversify contexts (e.g. `inversify` vs. `@theia/core/shared/inversify`).
 * If this is the case an instanceof check can return  false negative.
 * => use a simple typeguard instead.
 */
function isContainerModule(config: ContainerModule | ModuleConfiguration): config is ContainerModule {
    return hasNumberProp(config, 'id') && hasFunctionProp(config, 'registry');
}

/**
 * Union type for the set of {@link ContainerModule}s and addition {@link ModuleConfiguration}s
 * used to configure a DI container.
 */
export type ContainerConfiguration = Array<ContainerModule | ModuleConfiguration>;

/**
 * Can be passed to create DI container utility functions to configure additional modules or
 * remove (i.e. not load) default modules.
 */
export interface ModuleConfiguration {
    /** Set of modules that should be loaded into the container. Loading */
    add?: MaybeArray<ContainerModule>;
    /** Set of modules that should be loaded into the container */
    remove?: MaybeArray<ContainerModule>;
}

/**
 * Optional constructor options for {@link FeatureModule}s.
 */
export interface FeatureModuleOptions {
    /**
     * The set of feature modules that is required in order for this module to load.
     */
    requires?: MaybeArray<FeatureModule>;
    /**
     * Optional `featureId` that should be used. If omitted an id will be autogenerated
     */
    featureId?: symbol;
}
/**
 * A `FeatureModule` is a specialized {@link ContainerModule} that can declare dependencies to other {@link FeatureModule}.
 * A feature module will only be loaded into a container if all of its required modules haven been loaded before. T
 * Each feature module binds its `featureId` be default. This enables querying of existing container to check wether a
 * feature module has been loaded into this container.
 */

export class FeatureModule extends ContainerModule {
    readonly featureId: symbol;

    readonly requires?: MaybeArray<FeatureModule>;

    constructor(registry: interfaces.ContainerModuleCallBack, options: FeatureModuleOptions = {}) {
        super((bind, unbind, isBound, ...rest) => {
            if (this.configure(bind, isBound)) {
                registry(bind, unbind, isBound, ...rest);
            }
        });
        this.featureId = options.featureId ?? this.createFeatureId();
        this.requires = options.requires;
    }

    protected createFeatureId(): symbol {
        return Symbol(this.id);
    }

    /**
     * Configures the feature module i.e. checks if the requirements are met.
     * If this is the case the {@link FeatureModule.featureId} will be bound and the module will be loaded
     * @param bind container bind function
     * @param isBound container isBound function
     * @returns `true` if all requirements are met and the module is loaded. `false` otherwise
     */
    configure(bind: interfaces.Bind, isBound: interfaces.IsBound): boolean {
        if (this.checkRequirements(isBound)) {
            bind(this.featureId).toConstantValue(this.featureId);
            return true;
        }
        return false;
    }

    /**
     * Checks if all required {@link FeatureModule}s are already loaded/bound in the container.
     * @param isBound The `isBound` property of the module callback. Used to check the required modules.
     * @returns `true` if all requirements are met, `false` otherwise
     */
    protected checkRequirements(isBound: interfaces.IsBound): boolean {
        return this.requires ? asArray(this.requires).every(module => isBound(module.featureId)) : true;
    }

    isLoaded(context: Pick<BindingContext, 'isBound'>): boolean {
        return context.isBound(this.featureId);
    }
}
/**
 * Checks wether the given service identifier is already bound in the given context
 * then either calls  the `bind` or `rebind` function respectively.
 *
 * As this is just a convenience function
 * ```ts
 * bindOrRebind({bind,isBound,rebind}, MyService).to(SomeOtherService);
 * ```
 * is equivalent to:
 * ```
 * if (isBound(MyService)) {
 *    rebind(MyService).to(SomeOtherService);
 * } else {
 *    bind(MyService).to(SomeOtherService);
 * }
 * ```
 * @param context The binding context
 * @param serviceIdentifier The service identifier
 * @returns The result of the `bind` or `rebind` function
 */
export function bindOrRebind<T>(
    context: Omit<BindingContext, 'unbind'>,
    serviceIdentifier: interfaces.ServiceIdentifier<T>
): interfaces.BindingToSyntax<T> {
    if (context.isBound(serviceIdentifier)) {
        return context.rebind(serviceIdentifier);
    }
    return context.bind(serviceIdentifier);
}

/**
 * Only binds the given service identifier if it's not already bound in the given context.
 *
 * As this is just a convenience function
 * ```ts
 * lazyBind({bind,isBound}, MyService)?.to(SomeOtherService);
 * ```
 * is equivalent to:
 * ```
 * if (!isBound(MyService)) {
 *    bind(MyService).to(SomeOtherService);
 * }
 * ```
 * @param context The binding context
 * @param serviceIdentifier The service identifier
 * @returns The result of the `bind` function or `undefined` if the service was already bound
 */
export function lazyBind<T>(
    context: Pick<BindingContext, 'bind' | 'isBound'>,
    serviceIdentifier: interfaces.ServiceIdentifier<T>
): interfaces.BindingToSyntax<T> | undefined {
    if (context.isBound(serviceIdentifier)) {
        return undefined;
    }
    return context.bind(serviceIdentifier);
}

/**
 * Binds the given service identifier to the given target service in the given context.
 * In addition, the target service is bound to itself in singleton scope. This ensures
 * that services can be rebound individually even if they are multi-injected.
 *
 * As this is just a convenience function
 * ```ts
 * bindAsService(bind,SomeOtherService,MyServiceImpl);
 * ```
 * is equivalent to:
 * ```ts
 * bind(MyServiceImpl).toSelf.inSingletonScope():
 * bind(SomeOtherService).toService(MyServiceImpl);
 * ```
 * @param serviceIdentifier
 * @param toServiceIdentifier
 */
export function bindAsService<S, T extends S>(
    context: Pick<BindingContext, 'bind'> | interfaces.Bind,
    serviceIdentifier: interfaces.ServiceIdentifier<S>,
    targetService: interfaces.ServiceIdentifier<T>
): void {
    const bind = typeof context === 'object' ? context.bind.bind(context) : context;
    bind(targetService).toSelf().inSingletonScope();
    bind(serviceIdentifier).toService(targetService);
}
